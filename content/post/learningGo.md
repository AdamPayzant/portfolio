---
title: Learning GoLang
description: My experience delving into learning the Go programming language
date: "2021-03-07T16:27:47-05:00"
publishDate: "2021-03-07T16:27:47-05:00"
---

I finally decided to tackle learning GoLang

---

So I've been wanting to learn Go for a while now. It's always seemed like an interesting langauge, but I've just not really had the situation to push me to learn. However, this semester I had a project that could be implemented in any language of our choice and the tech stack my group and I decided on was fully compatible and had stable versions in Go so I figured this is the perfect time to learn. Given my experience in C/C++, JS, and Python picking up writing Go code was fairly straightforward. Simple things like the null keyword being `nil`, the lack of semicolons, and variables being initialized in "`var <name> <type>`" tripped me up for the first little while, but after spending a week on it I was pretty good to go. Language quirks aside though, there's certainly things I've come to appreciate in the language and things I have some major gripes with.

Focusing on the positive, I find the way the language does garbage collection very interesting. Most garbage collected languages I've used restrict access to pointers/references, which is often my biggest annoyance. My biggest annoyance in Java is how I can't control how things are passed. There are situations where I may want to pass an `int` by reference. Go doesn't just allow the usage of pointers, but if you have a pointer to data that goes out of scope, the data will continue to exist until all pointers are gone (somewhat reminds me of smart pointers in C++). While this garbage collection does carry a perfomance penalty (I wouldn't write Go code to compete with C performance), it's a massive quality of life gain while also improving confidence in memory safety. On another note, I love the way Go does structs. To explain this better, I need to address my opinions on programming styles. I'm not sure if I've mentioned here, but I take issue with a lot of object oriented programming. Objects are great, especially things for things like data structures where data and functions are fundamentally tied. That said, OOP can create code that isn't easily parallelized and can become very difficult to maintain as state becomes very difficult to track. With this all in mind, Go's structs are as the name implies. They're structs, not objects, meaning state is seperate from functions. C and even C++ have those though, so what makes Go's structs special? Well in Go, structs allow for functions to be tied to them. This allows for an easy OOP style programming when the archetecture calls for it (such as when writing a data structure), but creates a culture that discourages OO programming for the sake of OOP. While these are huge selling points to me personally, I'm missing probably the biggest selling point of Go, the goroutine. What's amazing about go routines is they're as trivial as async functions to write and aren't just concurrent but parallel! The addition of channels to simplify communication between goroutines makes Go probably the most enjoyable multithreading experience I've had (even moreso than Rust though my experience is far too limited to say conclusively).

That all said, I still have some annoyances with the language. I'm not a fan of the packaging system. While it brings some interesting ideas to the table, I found the documentation annoyingly lacking in terms of beginner friendliness, especially in terms of using local packages. For the project I decided to learn Go with we're using gRPC (a remote procedure call system). This involved building `.proto` files into Go files as non-main packages. In addition, because our archetecture uses multiple types of RPC servers, this meant that we're building 3 seperate packages. My initial understanding was I could just run `go install .` in the directory of the RPC package and it would just install, but this turned out to not work. After spending an embarrassingly long time with numerous faulty recommendations, I finally found that I needed to make a `go.mod` in the parent directory of the 3 packages. My biggest annoyance with all of this is just that there's seemingly no easy way to install single purpose packages locally, though I realize that isn't really the intention of the package system. With time this system may grow on me, but as it stands I currently find it more annoying to deal with than C++ libraries (which is sadly a low bar given go does have proper package management). That's actually my biggest complaint as everything else is kinda nitpicky. I guess my biggest push for an explicit change is to allow developers to explictly defer goroutines. Deferring in Go is how you can specify a function to run at the end of the current scope. My annoyance is that this is handled before the return, so the scope calling defer won't actually end until the defered function is also done. This would be fine if you could defer calling goroutines, but as it stands that's not an option, requiring a kinda hacky workaround to do so. I also dislike (but understand why) unused variables throw errors, especially considering functions can have multiple returns and you may not need all returns.

This all said, overall I am enjoying GoLang, and I believe it will be quite valuable to have in my repertoire of languages.